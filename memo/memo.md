# 名前重複

　`token.py`を作ったら標準ライブラリと名前重複しやがった。

* [token](https://docs.python.org/ja/3/library/token.html)

# メタデータ

　固定値をファイルで管理する。

　それ以外の以下は、プログラミングのコードによって自動生成したい。

* Help
    * usage
    * sub-commands
    * paremeters
* ReadMe
    * instllation
    * system_requirements
        * os, middle-ware, farm-ware
        * package-manager, tools(commands)
        * sdk, packages(library, framework)
        * language

　ソフトウェアには以下の項目がある。名前はpackage-managerによって変わる。

* name, version, edition

# スコープ

　スコープとは、そのトークンがもつ権限である。

　トークンはできるだけ小さいスコープをもつことが推奨される。なぜなら漏洩したとき、不正に操作される範囲が小さくて済むからだ。

　それなら本アプリもできるだけ小さいスコープをもつトークンを選出すべきである。そのアルゴリズムを考えたい。

　GitHubやMastodonのトークンにおけるスコープをみると、次のような特徴がある。

* 文字列である
* 階層構造は`:`で表している
* どのWebAPIがどんなスコープをもつかはサービス内容に依存する

　影響範囲の評価は、いくつか考えられる。

* 子スコープの所持数だけ点数をもつ
* 点数が低いスコープを算出する

　たとえばMastodonの`read`は以下11個の子スコープを持っている。なので`read`スコープの影響範囲点数は`11`とする。

```
read:accounts
read:blocks
read:bookmarks
read:favourites
read:filters
read:follows
read:lists
read:mutes
read:notifications
read:search
read:statuses
```

　こうすれば大カテゴリは点数が高いため優先順位をさげるというアルゴリズムがつくれる。しかし、最初に挙げた問題のせいでむずかしい。それは「どのWebAPIがどんなスコープをもつかはサービス内容に依存する」ということだ。

　たとえばGitHubにはそもそも`read`というスコープはない。それどころか、スコープの包含関係すらスコープ名の`:`だけで示せない。たとえば`write:discussion`は`read:discussion`を包含する。書き込むなら読込もしたいのが自然だからだろう。

　このようにスコープの名前と包含関係には、必ずしも関係がない。それらは個別に定義せねば正確には処理できない。だが、それにかける費用対効果が低すぎる。

* あらゆるサイトのスコープ関係を実装せねばならない
* あらゆるサイトのサービスは頻繁に変更されうる
    * そのたびにスコープ名の変更や増減に対応せねばならない

　はっきりいって対応できるわけがない。企業の数に対して、このコードを管理しているのは私一人だけだからだ。

　よって、本アプリではスコープを単純に文字列の完全一致で検索することにした。

　スコープの包含関係を表現できない。そのせいで本来は返すべきトークンが返されない。`read:statuses`があればいいのにそれを包含する`read`をもったトークンが返されない。

　だが、そこは運用でカバーしてほしい。たとえば別途`read:statuses`だけのトークンを作るなど。トークンはできるだけスコープを小さくしたほうがよい。むしろ作成した時点ですでに大スコープを選んでしまったなら、それはもうすでに危険だ。万一漏洩したら影響範囲が大きい。そもそも大カテゴリのトークンを作るべきなのかよく検討すべきだ。大抵の場合、長いスコープ名を入力したくないから大カテゴリを選ぶ。そうして大カテゴリを作ってしまった時点で、すでにカテゴリの大小などささいな問題だ。そんなことを気にする前に、過剰なスコープを厳選すべきである。それはユーザの責任だ。本アプリの責任ではない。そこに本アプリが力を注ぐ理由はない。

　よって、スコープ名の完全一致検索は、実装を簡略化しつつ小さなスコープだけをヒットさせるたったひとつの冴えたやりかたなのである。

